generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model ArchivedTask {
  id          Int      @id @default(autoincrement())
  userId      Int
  title       String   @db.VarChar(30)
  description String?
  created_at  DateTime @default(now()) @db.Timestamp(6)
  User        User     @relation(fields: [userId], references: [id])
}

model Category {
  id           Int            @id @default(autoincrement())
  categoryName String         @db.VarChar(50)
  userId       Int?
  User         User?          @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_user")
  TaskCategory TaskCategory[]
}

model Comment {
  id         Int      @id @default(autoincrement())
  content    String
  userId     Int
  taskId     Int
  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt
  Task       Task     @relation(fields: [taskId], references: [id])
  User       User     @relation(fields: [userId], references: [id])
}

model Subtask {
  id             Int              @id @default(autoincrement())
  title          String           @db.VarChar(30)
  description    String?
  status         Status
  taskId         Int
  priority       Priority
  updatedBy      Int?
  created_at     DateTime         @default(now()) @db.Timestamp(6)
  updated_at     DateTime         @updatedAt
  Task           Task             @relation(fields: [taskId], references: [id])
  User           User?            @relation(fields: [updatedBy], references: [id])
  SubtaskComment SubtaskComment[]
}

model SubtaskComment {
  id         Int      @id @default(autoincrement())
  content    String
  userId     Int
  subtaskId  Int
  created_at DateTime @default(now()) @db.Timestamp(6)
  updated_at DateTime @updatedAt
  Subtask    Subtask  @relation(fields: [subtaskId], references: [id])
  User       User     @relation(fields: [userId], references: [id])
}

model Task {
  id                        Int            @id @default(autoincrement())
  title                     String         @db.VarChar(30)
  description               String?
  status                    Status
  userId                    Int
  priority                  Priority
  updatedBy                 Int?
  created_at                DateTime       @default(now()) @db.Timestamp(6)
  updated_at                DateTime       @updatedAt
  Comment                   Comment[]
  Subtask                   Subtask[]
  User_Task_updatedByToUser User?          @relation("Task_updatedByToUser", fields: [updatedBy], references: [id])
  User_Task_userIdToUser    User           @relation("Task_userIdToUser", fields: [userId], references: [id])
  TaskCategory              TaskCategory[]
}

model TaskCategory {
  id         Int      @id @default(autoincrement())
  taskId     Int
  categoryId Int
  Category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  Task       Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
}

model User {
  id                        Int              @id @default(autoincrement())
  username                  String           @db.VarChar(100)
  first_name                String           @db.VarChar(100)
  last_name                 String           @db.VarChar(100)
  email                     String           @unique @db.VarChar(100)
  password                  String           @db.VarChar(255)
  created_at                DateTime         @default(now()) @db.Timestamp(6)
  ArchivedTask              ArchivedTask[]
  Category                  Category[]
  Comment                   Comment[]
  Subtask                   Subtask[]
  SubtaskComment            SubtaskComment[]
  Task_Task_updatedByToUser Task[]           @relation("Task_updatedByToUser")
  Task_Task_userIdToUser    Task[]           @relation("Task_userIdToUser")
}

enum Status {
  TO_DO
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
  DEFERRED
}

enum Priority {
  OPTIONAL
  LOW
  MEDIUM
  HIGH
  CRITICAL
  ASAP
}
